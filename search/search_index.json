{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Terra-py Python library for Terra Core Example import os from terra import Account, msg acc = Account(os.getenv('MNEMONIC')) # or generate a new one # acc = Account.generate() delegate = msg.staking.MsgDelegate( delegator_address=acc.account_address, validator_address='terravaloper1p54hc4yy2ajg67j645dn73w3378j6k05vmx9r2', amount=msg.Coin(amount='10000', denom='uluna') ) tx = msg.Tx( fee=msg.Fee('10000', [msg.Coin('2000', 'uluna')]), memo='Delegating my LUNA tokens', msg=[delegate], ) tx.sign_with(acc) tx.to_json()","title":"Home"},{"location":"#terra-py","text":"Python library for Terra Core","title":"Terra-py"},{"location":"#example","text":"import os from terra import Account, msg acc = Account(os.getenv('MNEMONIC')) # or generate a new one # acc = Account.generate() delegate = msg.staking.MsgDelegate( delegator_address=acc.account_address, validator_address='terravaloper1p54hc4yy2ajg67j645dn73w3378j6k05vmx9r2', amount=msg.Coin(amount='10000', denom='uluna') ) tx = msg.Tx( fee=msg.Fee('10000', [msg.Coin('2000', 'uluna')]), memo='Delegating my LUNA tokens', msg=[delegate], ) tx.sign_with(acc) tx.to_json()","title":"Example"},{"location":"contribute/","text":"Contribute This project uses poetry to manage dependencies and packaging. Install poetry The recommanded way to install poetry is through it's custom installer that adds vendorized dependencies to make it independant from your system. curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py | python General Install dependencies poetry install Format Code poetry run black . Linting and code style poetry run flake8 . Static type checking poetry run mypy --ignore-missing-imports . Run tests and check coverage poetry run coverage run --source terra -m pytest -v poetry run coverage report Serve documentation poetry run mkdocs serve Contributing Open a PR against develop.","title":"Contribute"},{"location":"contribute/#contribute","text":"This project uses poetry to manage dependencies and packaging.","title":"Contribute"},{"location":"contribute/#install-poetry","text":"The recommanded way to install poetry is through it's custom installer that adds vendorized dependencies to make it independant from your system. curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py | python","title":"Install poetry"},{"location":"contribute/#general","text":"","title":"General"},{"location":"contribute/#install-dependencies","text":"poetry install","title":"Install dependencies"},{"location":"contribute/#format-code","text":"poetry run black .","title":"Format Code"},{"location":"contribute/#linting-and-code-style","text":"poetry run flake8 .","title":"Linting and code style"},{"location":"contribute/#static-type-checking","text":"poetry run mypy --ignore-missing-imports .","title":"Static type checking"},{"location":"contribute/#run-tests-and-check-coverage","text":"poetry run coverage run --source terra -m pytest -v poetry run coverage report","title":"Run tests and check coverage"},{"location":"contribute/#serve-documentation","text":"poetry run mkdocs serve","title":"Serve documentation"},{"location":"contribute/#contributing","text":"Open a PR against develop.","title":"Contributing"},{"location":"installation/","text":"Installation Requirements: Python >= 3.6 Virtualenv virtualenv -p python3.6 .venv source .venv/bin/activate pip install terra-core Poetry poetry add terra-core Pipenv pipenv install terra-core System (not recommended) Warning It is not reccomended to install packages directly to your system. Please use a virtualenv or a dependency management tool. # system wide pip3 install terra-core # or user specific pip3 install --user terra-core","title":"Installation"},{"location":"installation/#installation","text":"Requirements: Python >= 3.6","title":"Installation"},{"location":"installation/#virtualenv","text":"virtualenv -p python3.6 .venv source .venv/bin/activate pip install terra-core","title":"Virtualenv"},{"location":"installation/#poetry","text":"poetry add terra-core","title":"Poetry"},{"location":"installation/#pipenv","text":"pipenv install terra-core","title":"Pipenv"},{"location":"installation/#system-not-recommended","text":"Warning It is not reccomended to install packages directly to your system. Please use a virtualenv or a dependency management tool. # system wide pip3 install terra-core # or user specific pip3 install --user terra-core","title":"System (not recommended)"},{"location":"modules/","text":"Modules Documentation of the modules apis. terra Account: Account( mnemonic: str account: int = 0, index: int = 0, chain_id: str = \"columbus-2\", ) Account().generate() -> Account Exceptions: # Raised when an error occured while communicating with the API ApiError() terra.api The api module is wrapping some endpoints from Terra lcd server . You can change the api endpoint used by setting: terra.api.Client.URL = \"https://my.lcd.server\" Client: Client() Client.get( path: str, params: Optional[Dict[str, str]] = None, timeout: Optional[int] = 5, ) -> dict Client.post( path: str, json: Optional[Dict[str, str]], params: Optional[Dict[str, str]] = None, timeout: Optional[int] = 10, ) -> dict Note : You should probably not have to use this class. It is meant for internal use. terra.api.auth accounts: accounts.get( address: str ) -> dict terra.api.oracle denoms: denoms.get() -> dict terra.api.tendermint blocks: blocks.get() -> dict node_info: node_info.get() -> dict txs: txs.post(tx_dump: str) -> dict terra.msg Coin: Coin( amount: str, denom: str, ) Coin().to_json( sort: bool = False, ) -> str Fee: Fee( gas: str, amount: List[terra.msg.Coin], ) Fee().to_json( sort: bool = False, ) -> str InOut: InOut( address: str, coins: List[terra.msg.Coin], ) InOut().to_json( sort: bool = False, ) -> str ReturnType: ReturnType() ReturnType.BLOCK ReturnType.ASYNC ReturnType.SYNC Tx: Tx( fee: terra.msg.Fee, memo: str = \"\", mode: str = terra.msg.ReturnType.BLOCK, msg: List[terra.utils.JsonSerializable] = [], signatures: List[terra.msg.auth.StdSignMessage] = [], ) Tx().sign_with( account: terra.Account, ) -> None Tx().to_json( sort: bool = False, ) -> str terra.msg.auth StdSignMsg: StdSignMsg( signature: str, pub_key_value: str, pub_key_type: str = \"tendermint/PubKeySecp256k1\", ) StdSignMsg().to_json( sort: bool = False, ) -> str StdTx: StdTx( fee: terra.msg.Fee, memo: str = \"\", msg: List[terra.utils.JsonSerializable] = [], # all terra.msg classes inherit from JsonSerializable signatures: List[terra.msg.auth.StdSignMessage] = [], ) StdTx().sign_with( account: terra.Account, ) -> None StdTx().to_json( sort: bool = False, ) -> str terra.msg.distribution MsgSetWithdrawAddress: MsgSetWithdrawAddress( delegator_address: str, withdraw_address: str, ) MsgSetWithdrawAddress().to_json( sort: bool = False, ) -> str MsgWithdrawDelegatorReward: MsgWithdrawDelegatorReward( delegator_address: str, validator_address: str, ) MsgWithdrawDelegatorReward().to_json( sort: bool = False, ) -> str terra.msg.market MsgSwap: MsgSwap( trader: str, offer_coin: terra.msg.Coin, ask_denom: str, ) MsgSwap().to_json( sort: bool = False, ) -> str terra.msg.oracle MsgPricePrevote: MsgPricePrevote( price: str, salt: str, denom: str, feeder: str, validator: str ) MsgPricePrevote().to_json( sort: bool = False, ) -> str MsgPriceVote: MsgPriceVote( price: str, salt: str, denom: str, feeder: str, validator: str, ) MsgPriceVote().to_json( sort: bool = False, ) -> str terra.msg.pay MsgMultiSend: MsgMultiSend( inputs: List[terra.msg.InOut], outputs: List[terra.msg.InOut], ) MsgMultiSend().to_json( sort: bool = False, ) -> str MsgSend: MsgSend( amount: List[terra.msg.Coin], from_address: str, to_address: str ) MsgSend().to_json( sort: bool = False, ) -> str terra.msg.staking MsgBeginRedelegate: MsgBeginRedelegate( delegator_address: str, validator_src_address: str, validator_dst_address: str, amount: terra.msg.Coin, ) MsgBeginRedelegate().to_json( sort: bool = False, ) -> str MsgDelegate: MsgDelegate( delegator_address: str, validator_address: str, amount: terra.msg.Coin, ) MsgDelegate().to_json( sort: bool = False, ) -> str MsgUndelegate: MsgUndelegate( delegator_address: str, validator_address: str, amount: terra.msg.Coin, ) MsgUndelegate().to_json( sort: bool = False, ) -> str terra.utils JsonSerializable: JsonSerializable() JsonSerializable().to_json( sort: bool = False, ) -> str terra.utils.crypto generate_salt: generate_salt() -> str sha256_and_sign: sha256_and_sign( payload: str, private_key: str, curve: ecdsa.curves.Curve = ecdsa.SECP256k1, canonize: bool = True, ) -> bytes sha256: sha256( payload: str, ) -> bytes","title":"Modules"},{"location":"modules/#modules","text":"Documentation of the modules apis.","title":"Modules"},{"location":"modules/#terra","text":"Account: Account( mnemonic: str account: int = 0, index: int = 0, chain_id: str = \"columbus-2\", ) Account().generate() -> Account Exceptions: # Raised when an error occured while communicating with the API ApiError()","title":"terra"},{"location":"modules/#terraapi","text":"The api module is wrapping some endpoints from Terra lcd server . You can change the api endpoint used by setting: terra.api.Client.URL = \"https://my.lcd.server\" Client: Client() Client.get( path: str, params: Optional[Dict[str, str]] = None, timeout: Optional[int] = 5, ) -> dict Client.post( path: str, json: Optional[Dict[str, str]], params: Optional[Dict[str, str]] = None, timeout: Optional[int] = 10, ) -> dict Note : You should probably not have to use this class. It is meant for internal use.","title":"terra.api"},{"location":"modules/#terraapiauth","text":"accounts: accounts.get( address: str ) -> dict","title":"terra.api.auth"},{"location":"modules/#terraapioracle","text":"denoms: denoms.get() -> dict","title":"terra.api.oracle"},{"location":"modules/#terraapitendermint","text":"blocks: blocks.get() -> dict node_info: node_info.get() -> dict txs: txs.post(tx_dump: str) -> dict","title":"terra.api.tendermint"},{"location":"modules/#terramsg","text":"Coin: Coin( amount: str, denom: str, ) Coin().to_json( sort: bool = False, ) -> str Fee: Fee( gas: str, amount: List[terra.msg.Coin], ) Fee().to_json( sort: bool = False, ) -> str InOut: InOut( address: str, coins: List[terra.msg.Coin], ) InOut().to_json( sort: bool = False, ) -> str ReturnType: ReturnType() ReturnType.BLOCK ReturnType.ASYNC ReturnType.SYNC Tx: Tx( fee: terra.msg.Fee, memo: str = \"\", mode: str = terra.msg.ReturnType.BLOCK, msg: List[terra.utils.JsonSerializable] = [], signatures: List[terra.msg.auth.StdSignMessage] = [], ) Tx().sign_with( account: terra.Account, ) -> None Tx().to_json( sort: bool = False, ) -> str","title":"terra.msg"},{"location":"modules/#terramsgauth","text":"StdSignMsg: StdSignMsg( signature: str, pub_key_value: str, pub_key_type: str = \"tendermint/PubKeySecp256k1\", ) StdSignMsg().to_json( sort: bool = False, ) -> str StdTx: StdTx( fee: terra.msg.Fee, memo: str = \"\", msg: List[terra.utils.JsonSerializable] = [], # all terra.msg classes inherit from JsonSerializable signatures: List[terra.msg.auth.StdSignMessage] = [], ) StdTx().sign_with( account: terra.Account, ) -> None StdTx().to_json( sort: bool = False, ) -> str","title":"terra.msg.auth"},{"location":"modules/#terramsgdistribution","text":"MsgSetWithdrawAddress: MsgSetWithdrawAddress( delegator_address: str, withdraw_address: str, ) MsgSetWithdrawAddress().to_json( sort: bool = False, ) -> str MsgWithdrawDelegatorReward: MsgWithdrawDelegatorReward( delegator_address: str, validator_address: str, ) MsgWithdrawDelegatorReward().to_json( sort: bool = False, ) -> str","title":"terra.msg.distribution"},{"location":"modules/#terramsgmarket","text":"MsgSwap: MsgSwap( trader: str, offer_coin: terra.msg.Coin, ask_denom: str, ) MsgSwap().to_json( sort: bool = False, ) -> str","title":"terra.msg.market"},{"location":"modules/#terramsgoracle","text":"MsgPricePrevote: MsgPricePrevote( price: str, salt: str, denom: str, feeder: str, validator: str ) MsgPricePrevote().to_json( sort: bool = False, ) -> str MsgPriceVote: MsgPriceVote( price: str, salt: str, denom: str, feeder: str, validator: str, ) MsgPriceVote().to_json( sort: bool = False, ) -> str","title":"terra.msg.oracle"},{"location":"modules/#terramsgpay","text":"MsgMultiSend: MsgMultiSend( inputs: List[terra.msg.InOut], outputs: List[terra.msg.InOut], ) MsgMultiSend().to_json( sort: bool = False, ) -> str MsgSend: MsgSend( amount: List[terra.msg.Coin], from_address: str, to_address: str ) MsgSend().to_json( sort: bool = False, ) -> str","title":"terra.msg.pay"},{"location":"modules/#terramsgstaking","text":"MsgBeginRedelegate: MsgBeginRedelegate( delegator_address: str, validator_src_address: str, validator_dst_address: str, amount: terra.msg.Coin, ) MsgBeginRedelegate().to_json( sort: bool = False, ) -> str MsgDelegate: MsgDelegate( delegator_address: str, validator_address: str, amount: terra.msg.Coin, ) MsgDelegate().to_json( sort: bool = False, ) -> str MsgUndelegate: MsgUndelegate( delegator_address: str, validator_address: str, amount: terra.msg.Coin, ) MsgUndelegate().to_json( sort: bool = False, ) -> str","title":"terra.msg.staking"},{"location":"modules/#terrautils","text":"JsonSerializable: JsonSerializable() JsonSerializable().to_json( sort: bool = False, ) -> str","title":"terra.utils"},{"location":"modules/#terrautilscrypto","text":"generate_salt: generate_salt() -> str sha256_and_sign: sha256_and_sign( payload: str, private_key: str, curve: ecdsa.curves.Curve = ecdsa.SECP256k1, canonize: bool = True, ) -> bytes sha256: sha256( payload: str, ) -> bytes","title":"terra.utils.crypto"}]}